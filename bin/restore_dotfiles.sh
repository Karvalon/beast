#!/usr/bin/env bash
# VaultMesh Dotfiles Restore Utility
# Generated by VaultMesh Dotfiles Management System

set -euo pipefail

# Configuration
DOTFILES_DIR="${DOTFILES_DIR:-$HOME/.dotfiles}"
BACKUP_BASE_DIR="${DOTFILES_BACKUP_DIR:-$HOME/.dotfiles.backup}"

# Logging function
log_message() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    echo "[$timestamp] [$level] $message"
    
    # Also log to memory if available
    if [[ -w "$DOTFILES_DIR/memory/memory.log" ]]; then
        echo "$timestamp: restore-dotfiles [$level] $message" >> "$DOTFILES_DIR/memory/memory.log"
    fi
}

# Error handling
error_exit() {
    log_message "ERROR" "$1"
    exit 1
}

# Find available backups
find_backups() {
    local backup_dirs=()
    
    while IFS= read -r -d '' dir; do
        backup_dirs+=("$dir")
    done < <(find "$(dirname "$BACKUP_BASE_DIR")" -maxdepth 1 -name "$(basename "$BACKUP_BASE_DIR").*" -type d -print0 2>/dev/null | sort -rz)
    
    printf '%s\n' "${backup_dirs[@]}"
}

# Validate backup directory
validate_backup() {
    local backup_dir="$1"
    
    if [[ ! -d "$backup_dir" ]]; then
        error_exit "Backup directory does not exist: $backup_dir"
    fi
    
    if [[ ! -f "$backup_dir/backup_info.txt" ]]; then
        log_message "WARN" "Backup info file not found: $backup_dir/backup_info.txt"
        log_message "WARN" "This may not be a valid VaultMesh backup"
    fi
    
    log_message "INFO" "Backup directory validated: $backup_dir"
}

# Show backup information
show_backup_info() {
    local backup_dir="$1"
    
    echo "📦 Backup Information:"
    echo "====================="
    echo "Location: $backup_dir"
    
    if [[ -f "$backup_dir/backup_info.txt" ]]; then
        cat "$backup_dir/backup_info.txt"
    else
        echo "No backup information available"
        
        # Try to show basic directory info
        local file_count=$(find "$backup_dir" -type f | wc -l)
        local dir_size=""
        if command -v du &> /dev/null; then
            dir_size=$(du -sh "$backup_dir" 2>/dev/null | cut -f1 || echo "unknown")
        fi
        
        echo ""
        echo "Files: $file_count"
        echo "Size: ${dir_size:-unknown}"
    fi
    
    echo ""
}

# List files in backup
list_backup_files() {
    local backup_dir="$1"
    
    echo "📁 Files in backup:"
    echo "==================="
    
    # Show files relative to backup directory
    find "$backup_dir" -type f -not -name "*.txt" -not -path "*/.*" | sed "s|^$backup_dir/||" | sort
    
    echo ""
}

# Create safety backup before restore
create_safety_backup() {
    local safety_dir="$HOME/.dotfiles.pre_restore.$(date +%Y%m%d_%H%M%S)"
    
    log_message "INFO" "Creating safety backup before restore: $safety_dir"
    
    # Use the backup script if available
    if command -v backup-dotfiles &> /dev/null; then
        DOTFILES_BACKUP_DIR="$safety_dir" backup-dotfiles --no-cleanup --quiet
    else
        # Simple manual backup
        mkdir -p "$safety_dir"
        
        local files_to_backup=(
            ".bashrc" ".zshrc" ".profile" ".bash_profile"
            ".gitconfig" ".vimrc" ".tmux.conf"
        )
        
        for file in "${files_to_backup[@]}"; do
            if [[ -f "$HOME/$file" ]]; then
                cp "$HOME/$file" "$safety_dir/" 2>/dev/null || true
            fi
        done
        
        # Backup .config directory
        if [[ -d "$HOME/.config" ]]; then
            cp -r "$HOME/.config" "$safety_dir/" 2>/dev/null || true
        fi
    fi
    
    log_message "SUCCESS" "Safety backup created: $safety_dir"
    echo "$safety_dir" > "$HOME/.dotfiles_last_safety_backup"
}

# Restore file from backup
restore_file() {
    local backup_dir="$1"
    local relative_path="$2"
    local force="$3"
    
    local backup_file="$backup_dir/$relative_path"
    local target_file="$HOME/$relative_path"
    
    if [[ ! -f "$backup_file" ]]; then
        log_message "DEBUG" "Backup file not found, skipping: $relative_path"
        return 0
    fi
    
    # Check if target file exists and handle accordingly
    if [[ -f "$target_file" ]] && [[ "$force" != true ]]; then
        read -p "File exists: $relative_path. Overwrite? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            log_message "INFO" "Skipped: $relative_path"
            return 0
        fi
    fi
    
    # Create parent directory if needed
    mkdir -p "$(dirname "$target_file")"
    
    # Copy file preserving attributes
    if cp -p "$backup_file" "$target_file"; then
        log_message "SUCCESS" "Restored: $relative_path"
        return 0
    else
        log_message "ERROR" "Failed to restore: $relative_path"
        return 1
    fi
}

# Restore directory from backup
restore_directory() {
    local backup_dir="$1"
    local relative_path="$2"
    local force="$3"
    
    local backup_dir_path="$backup_dir/$relative_path"
    local target_dir_path="$HOME/$relative_path"
    
    if [[ ! -d "$backup_dir_path" ]]; then
        log_message "DEBUG" "Backup directory not found, skipping: $relative_path"
        return 0
    fi
    
    # Check if target directory exists
    if [[ -d "$target_dir_path" ]] && [[ "$force" != true ]]; then
        read -p "Directory exists: $relative_path. Merge contents? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            log_message "INFO" "Skipped directory: $relative_path"
            return 0
        fi
    fi
    
    # Create parent directory if needed
    mkdir -p "$(dirname "$target_dir_path")"
    
    # Copy directory recursively
    if cp -rp "$backup_dir_path" "$target_dir_path"; then
        log_message "SUCCESS" "Restored directory: $relative_path"
        return 0
    else
        log_message "ERROR" "Failed to restore directory: $relative_path"
        return 1
    fi
}

# Selective restore with file picker
selective_restore() {
    local backup_dir="$1"
    local force="$2"
    
    echo "🔧 Selective Restore Mode"
    echo "========================"
    echo "Select files/directories to restore:"
    echo ""
    
    # Get list of items in backup
    local items=()
    while IFS= read -r -d '' item; do
        local relative_path="${item#$backup_dir/}"
        # Skip metadata files
        if [[ "$relative_path" != backup_info.txt ]] && [[ "$relative_path" != system_info.txt ]] && [[ "$relative_path" != *_packages.txt ]]; then
            items+=("$relative_path")
        fi
    done < <(find "$backup_dir" -type f -print0)
    
    if [[ ${#items[@]} -eq 0 ]]; then
        log_message "WARN" "No restorable items found in backup"
        return 1
    fi
    
    # Show items with numbers
    local i=1
    for item in "${items[@]}"; do
        echo "$i) $item"
        ((i++))
    done
    
    echo ""
    echo "Enter numbers (space-separated), 'all' for everything, or 'quit' to exit:"
    read -r selection
    
    case "$selection" in
        "quit"|"q"|"exit")
            log_message "INFO" "Selective restore cancelled"
            return 0
            ;;
        "all"|"a")
            # Restore all items
            for item in "${items[@]}"; do
                restore_file "$backup_dir" "$item" "$force"
            done
            ;;
        *)
            # Parse number selection
            for num in $selection; do
                if [[ "$num" =~ ^[0-9]+$ ]] && [[ $num -ge 1 ]] && [[ $num -le ${#items[@]} ]]; then
                    local item="${items[$((num-1))]}"
                    restore_file "$backup_dir" "$item" "$force"
                else
                    log_message "WARN" "Invalid selection: $num"
                fi
            done
            ;;
    esac
}

# Full restore from backup
full_restore() {
    local backup_dir="$1"
    local force="$2"
    
    log_message "INFO" "Starting full restore from: $backup_dir"
    
    local success_count=0
    local total_count=0
    
    # Restore files
    while IFS= read -r -d '' file; do
        local relative_path="${file#$backup_dir/}"
        
        # Skip metadata files
        if [[ "$relative_path" == backup_info.txt ]] || [[ "$relative_path" == system_info.txt ]] || [[ "$relative_path" == *_packages.txt ]]; then
            continue
        fi
        
        ((total_count++))
        if restore_file "$backup_dir" "$relative_path" "$force"; then
            ((success_count++))
        fi
    done < <(find "$backup_dir" -type f -print0)
    
    log_message "SUCCESS" "Full restore completed: $success_count/$total_count files"
}

# Restore shell configuration only
restore_shell_config() {
    local backup_dir="$1"
    local force="$2"
    
    log_message "INFO" "Restoring shell configuration files..."
    
    local shell_files=(
        ".bashrc"
        ".zshrc"
        ".profile"
        ".bash_profile"
        ".bash_aliases"
        ".inputrc"
        ".config/starship.toml"
    )
    
    local success_count=0
    
    for file in "${shell_files[@]}"; do
        if restore_file "$backup_dir" "$file" "$force"; then
            ((success_count++))
        fi
    done
    
    log_message "SUCCESS" "Shell configuration restore completed: $success_count files"
}

# Restore Git configuration only
restore_git_config() {
    local backup_dir="$1"
    local force="$2"
    
    log_message "INFO" "Restoring Git configuration files..."
    
    local git_files=(
        ".gitconfig"
        ".gitignore_global"
        ".config/git/config"
    )
    
    local success_count=0
    
    for file in "${git_files[@]}"; do
        if restore_file "$backup_dir" "$file" "$force"; then
            ((success_count++))
        fi
    done
    
    log_message "SUCCESS" "Git configuration restore completed: $success_count files"
}

# Show restore preview
show_restore_preview() {
    local backup_dir="$1"
    
    echo "🔍 Restore Preview"
    echo "=================="
    echo "The following files would be restored:"
    echo ""
    
    while IFS= read -r -d '' file; do
        local relative_path="${file#$backup_dir/}"
        
        # Skip metadata files
        if [[ "$relative_path" == backup_info.txt ]] || [[ "$relative_path" == system_info.txt ]] || [[ "$relative_path" == *_packages.txt ]]; then
            continue
        fi
        
        local target_file="$HOME/$relative_path"
        local status="NEW"
        
        if [[ -f "$target_file" ]]; then
            status="OVERWRITE"
        elif [[ -L "$target_file" ]]; then
            status="REPLACE_SYMLINK"
        fi
        
        echo "  [$status] $relative_path"
    done < <(find "$backup_dir" -type f -print0)
    
    echo ""
}

# Show usage information
show_usage() {
    cat << EOF
VaultMesh Dotfiles Restore Utility

Usage: $(basename "$0") [OPTIONS] [COMMAND]

Commands:
    list               List available backups
    info BACKUP_DIR    Show backup information
    preview BACKUP_DIR Preview restore changes
    full BACKUP_DIR    Full restore (default)
    selective BACKUP_DIR  Interactive file selection
    shell BACKUP_DIR   Restore shell config only
    git BACKUP_DIR     Restore Git config only

Options:
    -h, --help         Show this help message
    -v, --verbose      Enable verbose output
    -q, --quiet        Suppress non-error output
    -f, --force        Overwrite existing files without prompting
    --from BACKUP_DIR  Specify backup directory to restore from
    --no-safety        Skip creating safety backup
    --latest           Use the most recent backup

Examples:
    $(basename "$0") list                           # List backups
    $(basename "$0") --latest                       # Restore from latest backup
    $(basename "$0") --from /path/to/backup         # Restore from specific backup
    $(basename "$0") selective --latest             # Interactive restore from latest
    $(basename "$0") shell ~/.dotfiles.backup.xyz   # Restore only shell configs
EOF
}

# Select latest backup
get_latest_backup() {
    local backups=($(find_backups))
    
    if [[ ${#backups[@]} -eq 0 ]]; then
        error_exit "No backups found"
    fi
    
    echo "${backups[0]}"  # Already sorted in reverse order
}

# Interactive backup selection
select_backup_interactive() {
    local backups=($(find_backups))
    
    if [[ ${#backups[@]} -eq 0 ]]; then
        error_exit "No backups found"
    fi
    
    echo "📦 Available Backups:"
    echo "===================="
    
    local i=1
    for backup in "${backups[@]}"; do
        local backup_name=$(basename "$backup")
        local backup_date="${backup_name##*.}"
        
        # Try to format the date
        local formatted_date=""
        if [[ $backup_date =~ ^[0-9]{8}_[0-9]{6}$ ]]; then
            formatted_date=$(date -j -f "%Y%m%d_%H%M%S" "$backup_date" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || echo "$backup_date")
        else
            formatted_date="$backup_date"
        fi
        
        echo "$i) $backup_name ($formatted_date)"
        ((i++))
    done
    
    echo ""
    read -p "Select backup number (1-${#backups[@]}): " -r backup_num
    
    if [[ "$backup_num" =~ ^[0-9]+$ ]] && [[ $backup_num -ge 1 ]] && [[ $backup_num -le ${#backups[@]} ]]; then
        echo "${backups[$((backup_num-1))]}"
    else
        error_exit "Invalid backup selection: $backup_num"
    fi
}

# Main execution
main() {
    local command="full"
    local backup_dir=""
    local force=false
    local verbose=false
    local quiet=false
    local use_latest=false
    local skip_safety=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_usage
                exit 0
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -q|--quiet)
                quiet=true
                shift
                ;;
            -f|--force)
                force=true
                shift
                ;;
            --from)
                backup_dir="$2"
                shift 2
                ;;
            --latest)
                use_latest=true
                shift
                ;;
            --no-safety)
                skip_safety=true
                shift
                ;;
            list|info|preview|full|selective|shell|git)
                command="$1"
                if [[ $# -gt 1 ]] && [[ "$2" != -* ]]; then
                    backup_dir="$2"
                    shift 2
                else
                    shift
                fi
                ;;
            *)
                error_exit "Unknown option: $1. Use --help for usage information."
                ;;
        esac
    done
    
    # Redirect output if quiet mode
    if [[ "$quiet" == true ]]; then
        exec > /dev/null
    fi
    
    # Set verbose mode
    if [[ "$verbose" == true ]]; then
        set -x
    fi
    
    # Handle list command
    if [[ "$command" == "list" ]]; then
        local backups=($(find_backups))
        if [[ ${#backups[@]} -eq 0 ]]; then
            echo "No backups found."
            exit 0
        fi
        
        echo "📦 Available Backups:"
        echo "===================="
        for backup in "${backups[@]}"; do
            local backup_name=$(basename "$backup")
            local backup_date="${backup_name##*.}"
            local formatted_date=""
            
            if [[ $backup_date =~ ^[0-9]{8}_[0-9]{6}$ ]]; then
                formatted_date=$(date -j -f "%Y%m%d_%H%M%S" "$backup_date" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || echo "$backup_date")
            else
                formatted_date="$backup_date"
            fi
            
            echo "  $backup_name ($formatted_date)"
        done
        exit 0
    fi
    
    # Determine backup directory
    if [[ -z "$backup_dir" ]]; then
        if [[ "$use_latest" == true ]]; then
            backup_dir=$(get_latest_backup)
            log_message "INFO" "Using latest backup: $(basename "$backup_dir")"
        else
            backup_dir=$(select_backup_interactive)
        fi
    fi
    
    # Validate backup directory
    validate_backup "$backup_dir"
    
    # Execute command
    case "$command" in
        "info")
            show_backup_info "$backup_dir"
            ;;
        "preview")
            show_backup_info "$backup_dir"
            show_restore_preview "$backup_dir"
            ;;
        "full")
            show_backup_info "$backup_dir"
            
            if [[ "$skip_safety" != true ]]; then
                create_safety_backup
            fi
            
            if [[ "$force" != true ]]; then
                echo ""
                read -p "Proceed with full restore? (y/N): " -n 1 -r
                echo
                if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                    log_message "INFO" "Restore cancelled by user"
                    exit 0
                fi
            fi
            
            full_restore "$backup_dir" "$force"
            ;;
        "selective")
            show_backup_info "$backup_dir"
            
            if [[ "$skip_safety" != true ]]; then
                create_safety_backup
            fi
            
            selective_restore "$backup_dir" "$force"
            ;;
        "shell")
            show_backup_info "$backup_dir"
            
            if [[ "$skip_safety" != true ]]; then
                create_safety_backup
            fi
            
            restore_shell_config "$backup_dir" "$force"
            ;;
        "git")
            show_backup_info "$backup_dir"
            
            if [[ "$skip_safety" != true ]]; then
                create_safety_backup
            fi
            
            restore_git_config "$backup_dir" "$force"
            ;;
    esac
    
    log_message "SUCCESS" "Restore operation completed"
    
    # Show post-restore instructions
    if [[ "$command" != "info" ]] && [[ "$command" != "preview" ]]; then
        echo ""
        echo "✅ Restore completed!"
        echo "   Backup used: $(basename "$backup_dir")"
        
        if [[ -f "$HOME/.dotfiles_last_safety_backup" ]]; then
            local safety_backup=$(cat "$HOME/.dotfiles_last_safety_backup")
            echo "   Safety backup: $(basename "$safety_backup")"
        fi
        
        echo ""
        echo "🔄 Recommended next steps:"
        echo "   1. Restart your shell or source config files"
        echo "   2. Check that everything works as expected"
        echo "   3. Run 'dotfiles_status' to verify configuration"
    fi
}

# Run main function with all arguments
main "$@"
