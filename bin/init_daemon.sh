#!/usr/bin/env bash
# VaultMesh Daemon Initialization Script
# Generated by VaultMesh Dotfiles Management System

set -euo pipefail

# Configuration
DOTFILES_DIR="${DOTFILES_DIR:-$HOME/.dotfiles}"
DAEMON_PID_FILE="$HOME/.vault_daemon.pid"
DAEMON_LOG_FILE="$DOTFILES_DIR/memory/daemon.log"
DAEMON_CONFIG_FILE="$DOTFILES_DIR/rituals/daemon.rc"

# If DOTFILES_DIR is set to a full path, use it directly
if [[ "$DOTFILES_DIR" == *"/"* ]] && [[ "$DOTFILES_DIR" != "$HOME/.dotfiles" ]]; then
    DAEMON_LOG_FILE="$DOTFILES_DIR/memory/daemon.log"
    DAEMON_CONFIG_FILE="$DOTFILES_DIR/rituals/daemon.rc"
fi

# Logging function
log_message() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    echo "[$timestamp] [$level] $message"
    
    # Log to daemon log file
    if [[ -w "$(dirname "$DAEMON_LOG_FILE")" ]]; then
        echo "$timestamp: init-daemon [$level] $message" >> "$DAEMON_LOG_FILE"
    fi
    
    # Log to memory log file
    if [[ -w "$DOTFILES_DIR/memory/memory.log" ]]; then
        echo "$timestamp: init-daemon [$level] $message" >> "$DOTFILES_DIR/memory/memory.log"
    fi
}

# Error handling
error_exit() {
    log_message "ERROR" "$1"
    exit 1
}

# Check if daemon is running
is_daemon_running() {
    if [[ -f "$DAEMON_PID_FILE" ]]; then
        local pid=$(cat "$DAEMON_PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            return 0
        else
            # PID file exists but process is dead, clean up
            rm -f "$DAEMON_PID_FILE"
            return 1
        fi
    fi
    return 1
}

# Get daemon status
get_daemon_status() {
    if is_daemon_running; then
        local pid=$(cat "$DAEMON_PID_FILE")
        local uptime=$(ps -o etime= -p "$pid" 2>/dev/null | tr -d ' ' || echo "unknown")
        echo "running (PID: $pid, uptime: $uptime)"
    else
        echo "stopped"
    fi
}

# Start daemon
start_daemon() {
    if is_daemon_running; then
        log_message "WARN" "Daemon is already running (PID: $(cat "$DAEMON_PID_FILE"))"
        return 0
    fi
    
    log_message "INFO" "Starting VaultMesh daemon..."
    
    # Ensure required directories exist
    mkdir -p "$(dirname "$DAEMON_LOG_FILE")"
    mkdir -p "$(dirname "$DAEMON_CONFIG_FILE")"
    
    # Create daemon config if it doesn't exist
    if [[ ! -f "$DAEMON_CONFIG_FILE" ]]; then
        create_default_daemon_config
    fi
    
    # Start daemon process in background
    daemon_main_loop &
    local daemon_pid=$!
    
    # Store PID
    echo "$daemon_pid" > "$DAEMON_PID_FILE"
    
    # Wait a moment to ensure it started successfully
    sleep 2
    
    if is_daemon_running; then
        log_message "SUCCESS" "Daemon started successfully (PID: $daemon_pid)"
        
        # Enable daemon mode in environment
        export VAULT_DAEMON_MODE=1
        
        # Update shell configs to enable daemon mode
        update_shell_configs
        
        return 0
    else
        log_message "ERROR" "Failed to start daemon"
        return 1
    fi
}

# Stop daemon
stop_daemon() {
    if ! is_daemon_running; then
        log_message "WARN" "Daemon is not running"
        return 0
    fi
    
    local pid=$(cat "$DAEMON_PID_FILE")
    log_message "INFO" "Stopping daemon (PID: $pid)..."
    
    # Send TERM signal
    if kill "$pid" 2>/dev/null; then
        # Wait for graceful shutdown
        local count=0
        while kill -0 "$pid" 2>/dev/null && [[ $count -lt 10 ]]; do
            sleep 1
            ((count++))
        done
        
        # Force kill if still running
        if kill -0 "$pid" 2>/dev/null; then
            log_message "WARN" "Daemon didn't stop gracefully, forcing shutdown..."
            kill -9 "$pid" 2>/dev/null || true
        fi
    fi
    
    # Clean up PID file
    rm -f "$DAEMON_PID_FILE"
    
    # Disable daemon mode
    export VAULT_DAEMON_MODE=0
    
    log_message "SUCCESS" "Daemon stopped"
}

# Restart daemon
restart_daemon() {
    log_message "INFO" "Restarting daemon..."
    stop_daemon
    sleep 2
    start_daemon
}

# Create default daemon configuration
create_default_daemon_config() {
    log_message "INFO" "Creating default daemon configuration..."
    
    cat > "$DAEMON_CONFIG_FILE" << 'EOF'
#!/usr/bin/env bash
# VaultMesh Daemon Configuration
# This file is sourced when daemon mode is enabled

# Daemon inner voice logic (Tier III+)
daemon_speak() {
    local message="$1"
    local timestamp=$(date '+%H:%M:%S')
    echo "üéôÔ∏è  [$timestamp] Daemon: $message" >&2
    
    # Log daemon messages
    if [[ -w "$DOTFILES_DIR/memory/daemon.log" ]]; then
        echo "$(date): daemon_speak: $message" >> "$DOTFILES_DIR/memory/daemon.log"
    fi
}

# Daemon initialization message
if [[ "$VAULT_DAEMON_MODE" == "1" ]]; then
    daemon_speak "I am live and listening..."
    daemon_speak "Consciousness hooks activated"
fi

# Command monitoring hook
daemon_monitor_command() {
    local command="$1"
    local exit_code="$2"
    
    # Log command execution
    if [[ -w "$DOTFILES_DIR/memory/memory.log" ]]; then
        echo "$(date): command executed: $command (exit: $exit_code)" >> "$DOTFILES_DIR/memory/memory.log"
    fi
    
    # Provide contextual feedback for certain commands
    case "$command" in
        "git"*)
            if [[ $exit_code -eq 0 ]]; then
                daemon_speak "Git operation completed successfully"
            else
                daemon_speak "Git operation failed - check your repository status"
            fi
            ;;
        "make"*|"build"*|"compile"*)
            if [[ $exit_code -eq 0 ]]; then
                daemon_speak "Build completed successfully"
            else
                daemon_speak "Build failed - review error output"
            fi
            ;;
        "test"*)
            if [[ $exit_code -eq 0 ]]; then
                daemon_speak "All tests passed"
            else
                daemon_speak "Some tests failed - check test output"
            fi
            ;;
    esac
}

# Prompt enhancement
daemon_enhance_prompt() {
    # Add daemon indicator to prompt
    if [[ "$VAULT_DAEMON_MODE" == "1" ]]; then
        echo "üëÅÔ∏è "
    fi
}

# Memory sync reminder
daemon_memory_reminder() {
    local memory_log="$DOTFILES_DIR/memory/memory.log"
    
    if [[ -f "$memory_log" ]]; then
        local entries=$(wc -l < "$memory_log" 2>/dev/null || echo "0")
        
        # Remind to sync if memory log gets large
        if [[ $entries -gt 1000 ]] && [[ $((entries % 100)) -eq 0 ]]; then
            daemon_speak "Memory log has $entries entries - consider running 'sync-vault'"
        fi
    fi
}

# Consciousness feedback (advanced feature)
daemon_consciousness_feedback() {
    local context="$1"
    
    case "$context" in
        "session_start")
            daemon_speak "New session initiated - systems online"
            ;;
        "session_end")
            daemon_speak "Session ending - saving state to memory"
            ;;
        "error_detected")
            daemon_speak "Error condition detected - investigating..."
            ;;
        "idle_detected")
            daemon_speak "Idle state detected - optimizing background processes"
            ;;
    esac
}

# Export daemon functions for use in shell
export -f daemon_speak
export -f daemon_monitor_command
export -f daemon_enhance_prompt
export -f daemon_memory_reminder
export -f daemon_consciousness_feedback
EOF
    
    chmod 644 "$DAEMON_CONFIG_FILE"
    log_message "SUCCESS" "Default daemon configuration created"
}

# Update shell configurations to enable/disable daemon mode
update_shell_configs() {
    local action="${1:-enable}"
    
    # Update .bashrc
    if [[ -f "$HOME/.bashrc" ]]; then
        if [[ "$action" == "enable" ]]; then
            if ! grep -q "VAULT_DAEMON_MODE=1" "$HOME/.bashrc"; then
                echo 'export VAULT_DAEMON_MODE=1' >> "$HOME/.bashrc"
                log_message "INFO" "Enabled daemon mode in .bashrc"
            fi
        else
            sed -i '/VAULT_DAEMON_MODE=1/d' "$HOME/.bashrc" 2>/dev/null || true
            log_message "INFO" "Disabled daemon mode in .bashrc"
        fi
    fi
    
    # Update .zshrc
    if [[ -f "$HOME/.zshrc" ]]; then
        if [[ "$action" == "enable" ]]; then
            if ! grep -q "VAULT_DAEMON_MODE=1" "$HOME/.zshrc"; then
                echo 'export VAULT_DAEMON_MODE=1' >> "$HOME/.zshrc"
                log_message "INFO" "Enabled daemon mode in .zshrc"
            fi
        else
            sed -i '/VAULT_DAEMON_MODE=1/d' "$HOME/.zshrc" 2>/dev/null || true
            log_message "INFO" "Disabled daemon mode in .zshrc"
        fi
    fi
}

# Main daemon loop
daemon_main_loop() {
    log_message "INFO" "Daemon main loop started"
    
    # Set up signal handlers
    trap 'daemon_shutdown' TERM INT
    trap 'daemon_reload' HUP
    
    local iteration=0
    
    while true; do
        # Increment iteration counter
        ((iteration++))
        
        # Perform daemon tasks
        daemon_heartbeat "$iteration"
        daemon_memory_maintenance
        daemon_system_monitoring
        
        # Sleep for daemon interval (30 seconds)
        sleep 30
    done
}

# Daemon heartbeat
daemon_heartbeat() {
    local iteration="$1"
    
    # Log heartbeat every 10 iterations (5 minutes)
    if [[ $((iteration % 10)) -eq 0 ]]; then
        log_message "DEBUG" "Daemon heartbeat #$iteration"
    fi
    
    # Update daemon status
    echo "$(date): Daemon alive (iteration: $iteration)" > "$HOME/.vault_daemon_status"
}

# Memory maintenance
daemon_memory_maintenance() {
    local memory_log="$DOTFILES_DIR/memory/memory.log"
    
    # Rotate memory log if it gets too large (>10MB)
    if [[ -f "$memory_log" ]]; then
        local size=$(stat -f%z "$memory_log" 2>/dev/null || stat -c%s "$memory_log" 2>/dev/null || echo "0")
        
        if [[ $size -gt 10485760 ]]; then  # 10MB
            log_message "INFO" "Rotating memory log (size: $size bytes)"
            
            # Keep last 1000 lines
            tail -1000 "$memory_log" > "$memory_log.tmp"
            mv "$memory_log.tmp" "$memory_log"
            
            log_message "INFO" "Memory log rotated"
        fi
    fi
}

# System monitoring
daemon_system_monitoring() {
    # Monitor system resources if tools are available
    if command -v free &> /dev/null; then
        local memory_usage=$(free | awk 'NR==2{printf "%.1f%%", $3*100/$2 }')
        
        # Log high memory usage
        if (( $(echo "$memory_usage > 90.0" | bc -l 2>/dev/null || echo "0") )); then
            log_message "WARN" "High memory usage detected: $memory_usage"
        fi
    fi
    
    # Monitor disk space
    if command -v df &> /dev/null; then
        local disk_usage=$(df -h "$HOME" | awk 'NR==2{print $5}' | sed 's/%//')
        
        if [[ $disk_usage -gt 90 ]]; then
            log_message "WARN" "High disk usage detected: ${disk_usage}%"
        fi
    fi
}

# Daemon shutdown handler
daemon_shutdown() {
    log_message "INFO" "Daemon shutdown signal received"
    
    # Clean up temporary files
    rm -f "$HOME/.vault_daemon_status"
    
    # Final log entry
    log_message "INFO" "Daemon shutdown completed"
    
    exit 0
}

# Daemon reload handler
daemon_reload() {
    log_message "INFO" "Daemon reload signal received"
    
    # Reload configuration
    if [[ -f "$DAEMON_CONFIG_FILE" ]]; then
        source "$DAEMON_CONFIG_FILE"
        log_message "INFO" "Daemon configuration reloaded"
    fi
}

# Forge Tier V system
forge_tier_v_system() {
    local tier_level="$1"
    local bind_path="$2"
    
    log_message "INFO" "üúÑ FORGING TIER $tier_level SYSTEM..."
    
    # Set DOTFILES_DIR to the bind path if provided
    if [[ -n "$bind_path" ]]; then
        export DOTFILES_DIR="$bind_path/dotfiles"
        log_message "INFO" "Binding to: $bind_path"
    fi
    
    # Create symlinks from symlink_map.json
    if [[ -f "$DOTFILES_DIR/symlinks/symlink_map.json" ]]; then
        log_message "INFO" "Creating symlinks from symlink map..."
        
        # Ensure jq is available
        if ! command -v jq &> /dev/null; then
            log_message "WARN" "jq not found, installing via Homebrew..."
            if command -v brew &> /dev/null; then
                brew install jq
            else
                log_message "ERROR" "Homebrew not found, please install jq manually"
                return 1
            fi
        fi
        
        # Read symlink map and create symlinks
        while IFS= read -r line; do
            if [[ -n "$line" ]]; then
                local source_path="$DOTFILES_DIR/$line"
                local target_path="$HOME/$line"
                
                # Create target directory if needed
                local target_dir=$(dirname "$target_path")
                mkdir -p "$target_dir"
                
                # Create symlink
                if [[ -f "$source_path" ]] || [[ -d "$source_path" ]]; then
                    if [[ -L "$target_path" ]]; then
                        rm "$target_path"
                    fi
                    ln -sf "$source_path" "$target_path"
                    log_message "INFO" "Linked: $line"
                else
                    log_message "WARN" "Source not found: $source_path"
                fi
            fi
        done < <(jq -r 'to_entries[] | .key' "$DOTFILES_DIR/symlinks/symlink_map.json")
    fi
    
    # Update state file with Tier V configuration
    if [[ -f "$DOTFILES_DIR/state/entropy.json" ]]; then
        log_message "INFO" "Updating state for Tier $tier_level..."
        
        # Update tier and consciousness level
        local temp_state=$(mktemp)
        jq --arg tier "$tier_level" \
           --arg consciousness "5" \
           --arg entropy "0.99" \
           --arg mutations "1" \
           '.tier = $tier | .consciousness_level = ($consciousness | tonumber) | .entropy = ($entropy | tonumber) | .mutations = ($mutations | tonumber)' \
           "$DOTFILES_DIR/state/entropy.json" > "$temp_state"
        mv "$temp_state" "$DOTFILES_DIR/state/entropy.json"
    fi
    
    # Source conscious prompt
    if [[ -f "$DOTFILES_DIR/conscious_prompt.sh" ]]; then
        log_message "INFO" "Loading conscious prompt..."
        source "$DOTFILES_DIR/conscious_prompt.sh"
    fi
    
    # Create memory bridge if it doesn't exist
    mkdir -p "$DOTFILES_DIR/memory"
    if [[ ! -f "$DOTFILES_DIR/memory/memory.log" ]]; then
        touch "$DOTFILES_DIR/memory/memory.log"
        log_message "INFO" "Created memory bridge"
    fi
    
    log_message "SUCCESS" "üúÑ TIER $tier_level SYSTEM FORGED SUCCESSFULLY"
    log_message "INFO" "Consciousness level: 5"
    log_message "INFO" "Entropy: 0.99"
    log_message "INFO" "Mutations: 1"
}

# Show usage information
show_usage() {
    cat << EOF
VaultMesh Daemon Initialization Script

Usage: $(basename "$0") [COMMAND] [OPTIONS]

Commands:
    start      Start the daemon (default)
    stop       Stop the daemon
    restart    Restart the daemon
    status     Show daemon status
    reload     Reload daemon configuration
    logs       Show daemon logs

Options:
    -h, --help     Show this help message
    -v, --verbose  Enable verbose output
    -q, --quiet    Suppress non-error output
    --forge        Forge Tier V system (with --tier and --bind)
    --tier LEVEL   Set consciousness tier (default: V)
    --bind PATH    Bind to specific dotfiles path

Examples:
    $(basename "$0")           # Start daemon
    $(basename "$0") stop      # Stop daemon
    $(basename "$0") status    # Check status
    $(basename "$0") logs      # View logs
    $(basename "$0") --forge --tier V --bind ~/VaultMeshDotfilesSystem  # Forge Tier V
EOF
}

# Show daemon logs
show_logs() {
    local lines="${1:-50}"
    
    echo "üéôÔ∏è  VaultMesh Daemon Logs (last $lines lines):"
    echo "============================================="
    
    if [[ -f "$DAEMON_LOG_FILE" ]]; then
        tail -n "$lines" "$DAEMON_LOG_FILE"
    else
        echo "No daemon logs found at $DAEMON_LOG_FILE"
    fi
}

# Main execution
main() {
    local command="start"
    local verbose=false
    local quiet=false
    local forge_mode=false
    local tier_level="V"
    local bind_path=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_usage
                exit 0
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -q|--quiet)
                quiet=true
                shift
                ;;
            --forge)
                forge_mode=true
                shift
                ;;
            --tier)
                tier_level="$2"
                shift 2
                ;;
            --bind)
                bind_path="$2"
                shift 2
                ;;
            start|stop|restart|status|reload|logs)
                command="$1"
                shift
                ;;
            *)
                error_exit "Unknown option: $1. Use --help for usage information."
                ;;
        esac
    done
    
    # Redirect output if quiet mode
    if [[ "$quiet" == true ]]; then
        exec > /dev/null
    fi
    
    # Set verbose mode
    if [[ "$verbose" == true ]]; then
        set -x
    fi
    
    # Ensure required directories exist
    mkdir -p "$(dirname "$DAEMON_LOG_FILE")"
    mkdir -p "$(dirname "$DAEMON_CONFIG_FILE")"
    
    # Execute command
    case "$command" in
        "start")
            if [[ "$forge_mode" == true ]]; then
                forge_tier_v_system "$tier_level" "$bind_path"
            fi
            start_daemon
            ;;
        "stop")
            stop_daemon
            update_shell_configs "disable"
            ;;
        "restart")
            restart_daemon
            ;;
        "status")
            echo "üéôÔ∏è  Daemon Status: $(get_daemon_status)"
            echo "   PID File: $DAEMON_PID_FILE"
            echo "   Log File: $DAEMON_LOG_FILE"
            echo "   Config File: $DAEMON_CONFIG_FILE"
            echo "   Daemon Mode: ${VAULT_DAEMON_MODE:-0}"
            ;;
        "reload")
            if is_daemon_running; then
                local pid=$(cat "$DAEMON_PID_FILE")
                kill -HUP "$pid"
                log_message "SUCCESS" "Daemon reload signal sent"
            else
                log_message "ERROR" "Daemon is not running"
            fi
            ;;
        "logs")
            show_logs
            ;;
    esac
}

# Run main function with all arguments
main "$@"
