#!/usr/bin/env bash
# VaultMesh Dotfiles Backup Utility
# Generated by VaultMesh Dotfiles Management System

set -euo pipefail

# Configuration
DOTFILES_DIR="${DOTFILES_DIR:-$HOME/.dotfiles}"
BACKUP_BASE_DIR="${DOTFILES_BACKUP_DIR:-$HOME/.dotfiles.backup}"
BACKUP_DIR="$BACKUP_BASE_DIR.$(date +%Y%m%d_%H%M%S)"

# Files to backup
BACKUP_FILES=(
    ".bashrc"
    ".zshrc"
    ".profile"
    ".bash_profile"
    ".bash_aliases"
    ".inputrc"
    ".vimrc"
    ".gitconfig"
    ".gitignore_global"
    ".config/starship.toml"
    ".config/git/config"
    ".ssh/config"
    ".tmux.conf"
    ".screenrc"
)

# Directories to backup
BACKUP_DIRS=(
    ".config/nvim"
    ".config/vim"
    ".config/tmux"
    ".local/bin"
    ".ssh"
)

# Logging function
log_message() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    echo "[$timestamp] [$level] $message"
    
    # Also log to memory if available
    if [[ -w "$DOTFILES_DIR/memory/memory.log" ]]; then
        echo "$timestamp: backup-dotfiles [$level] $message" >> "$DOTFILES_DIR/memory/memory.log"
    fi
}

# Error handling
error_exit() {
    log_message "ERROR" "$1"
    exit 1
}

# Check if file or directory exists and is not a broken symlink
item_exists() {
    local item="$1"
    [[ -e "$item" || -L "$item" ]]
}

# Check if symlink points to dotfiles directory
is_dotfiles_symlink() {
    local item="$1"
    
    if [[ -L "$item" ]]; then
        local target=$(readlink "$item")
        [[ "$target" == "$DOTFILES_DIR"* ]]
    else
        return 1
    fi
}

# Create backup directory structure
create_backup_structure() {
    log_message "INFO" "Creating backup directory: $BACKUP_DIR"
    
    if ! mkdir -p "$BACKUP_DIR"; then
        error_exit "Failed to create backup directory: $BACKUP_DIR"
    fi
    
    # Create subdirectories
    mkdir -p "$BACKUP_DIR/.config"
    mkdir -p "$BACKUP_DIR/.ssh"
    mkdir -p "$BACKUP_DIR/.local/bin"
    
    # Create metadata file
    cat > "$BACKUP_DIR/backup_info.txt" << EOF
VaultMesh Dotfiles Backup
========================
Created: $(date)
Hostname: $(hostname)
User: $(whoami)
Source: $HOME
Dotfiles Dir: $DOTFILES_DIR
Backup Version: 1.0

Files and directories backed up:
EOF
}

# Backup individual file
backup_file() {
    local file="$1"
    local source_path="$HOME/$file"
    local backup_path="$BACKUP_DIR/$file"
    
    if item_exists "$source_path"; then
        # Create parent directory if needed
        mkdir -p "$(dirname "$backup_path")"
        
        if is_dotfiles_symlink "$source_path"; then
            log_message "INFO" "Skipping dotfiles symlink: $file"
            echo "SYMLINK (skipped): $file -> $(readlink "$source_path")" >> "$BACKUP_DIR/backup_info.txt"
        else
            # Copy file preserving attributes
            if cp -p "$source_path" "$backup_path" 2>/dev/null; then
                log_message "SUCCESS" "Backed up file: $file"
                echo "FILE: $file" >> "$BACKUP_DIR/backup_info.txt"
                return 0
            else
                log_message "WARN" "Failed to backup file: $file"
                echo "FAILED: $file" >> "$BACKUP_DIR/backup_info.txt"
                return 1
            fi
        fi
    else
        log_message "DEBUG" "File not found, skipping: $file"
        echo "NOT_FOUND: $file" >> "$BACKUP_DIR/backup_info.txt"
    fi
}

# Backup directory
backup_directory() {
    local dir="$1"
    local source_path="$HOME/$dir"
    local backup_path="$BACKUP_DIR/$dir"
    
    if item_exists "$source_path"; then
        if is_dotfiles_symlink "$source_path"; then
            log_message "INFO" "Skipping dotfiles symlink directory: $dir"
            echo "SYMLINK_DIR (skipped): $dir -> $(readlink "$source_path")" >> "$BACKUP_DIR/backup_info.txt"
        else
            # Copy directory recursively
            if cp -rp "$source_path" "$backup_path" 2>/dev/null; then
                log_message "SUCCESS" "Backed up directory: $dir"
                echo "DIRECTORY: $dir" >> "$BACKUP_DIR/backup_info.txt"
                return 0
            else
                log_message "WARN" "Failed to backup directory: $dir"
                echo "FAILED_DIR: $dir" >> "$BACKUP_DIR/backup_info.txt"
                return 1
            fi
        fi
    else
        log_message "DEBUG" "Directory not found, skipping: $dir"
        echo "NOT_FOUND_DIR: $dir" >> "$BACKUP_DIR/backup_info.txt"
    fi
}

# Backup shell history files
backup_shell_history() {
    log_message "INFO" "Backing up shell history files..."
    
    local history_files=(
        ".bash_history"
        ".zsh_history"
        ".history"
    )
    
    for hist_file in "${history_files[@]}"; do
        backup_file "$hist_file"
    done
}

# Backup package manager configurations
backup_package_configs() {
    log_message "INFO" "Backing up package manager configurations..."
    
    # Homebrew (macOS)
    if command -v brew &> /dev/null; then
        log_message "INFO" "Creating Homebrew package list..."
        brew list --formula > "$BACKUP_DIR/brew_packages.txt" 2>/dev/null || true
        brew list --cask > "$BACKUP_DIR/brew_casks.txt" 2>/dev/null || true
        echo "GENERATED: brew_packages.txt" >> "$BACKUP_DIR/backup_info.txt"
        echo "GENERATED: brew_casks.txt" >> "$BACKUP_DIR/backup_info.txt"
    fi
    
    # APT (Debian/Ubuntu)
    if command -v apt &> /dev/null; then
        log_message "INFO" "Creating APT package list..."
        dpkg --get-selections > "$BACKUP_DIR/apt_packages.txt" 2>/dev/null || true
        echo "GENERATED: apt_packages.txt" >> "$BACKUP_DIR/backup_info.txt"
    fi
    
    # YUM/DNF (Red Hat/Fedora)
    if command -v yum &> /dev/null || command -v dnf &> /dev/null; then
        log_message "INFO" "Creating YUM/DNF package list..."
        if command -v dnf &> /dev/null; then
            dnf list installed > "$BACKUP_DIR/dnf_packages.txt" 2>/dev/null || true
            echo "GENERATED: dnf_packages.txt" >> "$BACKUP_DIR/backup_info.txt"
        else
            yum list installed > "$BACKUP_DIR/yum_packages.txt" 2>/dev/null || true
            echo "GENERATED: yum_packages.txt" >> "$BACKUP_DIR/backup_info.txt"
        fi
    fi
    
    # Pacman (Arch Linux)
    if command -v pacman &> /dev/null; then
        log_message "INFO" "Creating Pacman package list..."
        pacman -Qqe > "$BACKUP_DIR/pacman_packages.txt" 2>/dev/null || true
        echo "GENERATED: pacman_packages.txt" >> "$BACKUP_DIR/backup_info.txt"
    fi
}

# Create system information snapshot
create_system_snapshot() {
    log_message "INFO" "Creating system information snapshot..."
    
    cat > "$BACKUP_DIR/system_info.txt" << EOF
System Information Snapshot
===========================
Date: $(date)
Hostname: $(hostname)
User: $(whoami)
OS: $(uname -s)
Kernel: $(uname -r)
Architecture: $(uname -m)
Shell: $SHELL
Home Directory: $HOME
Current Directory: $(pwd)

Environment Variables:
PATH=$PATH
SHELL=$SHELL
TERM=${TERM:-}
LANG=${LANG:-}
LC_ALL=${LC_ALL:-}

Git Configuration:
$(git config --global user.name 2>/dev/null || echo "Not set")
$(git config --global user.email 2>/dev/null || echo "Not set")

Installed Shells:
$(grep -E "/(bash|zsh|fish|tcsh|csh)$" /etc/shells 2>/dev/null || echo "Cannot read /etc/shells")

SSH Keys:
$(ls -la ~/.ssh/*.pub 2>/dev/null || echo "No public SSH keys found")
EOF

    echo "GENERATED: system_info.txt" >> "$BACKUP_DIR/backup_info.txt"
}

# Verify backup integrity
verify_backup() {
    log_message "INFO" "Verifying backup integrity..."
    
    local file_count=0
    local total_size=0
    
    while IFS= read -r -d '' file; do
        ((file_count++))
        if [[ -f "$file" ]]; then
            local size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "0")
            ((total_size += size))
        fi
    done < <(find "$BACKUP_DIR" -type f -print0)
    
    # Convert bytes to human readable
    local human_size=""
    if command -v numfmt &> /dev/null; then
        human_size=$(numfmt --to=iec "$total_size")
    else
        human_size="${total_size} bytes"
    fi
    
    cat >> "$BACKUP_DIR/backup_info.txt" << EOF

Backup Statistics:
==================
Total Files: $file_count
Total Size: $human_size
Verification: $(date)
Status: Complete
EOF

    log_message "SUCCESS" "Backup verification complete: $file_count files, $human_size"
}

# Clean up old backups
cleanup_old_backups() {
    local keep_count="${1:-5}"
    
    log_message "INFO" "Cleaning up old backups (keeping $keep_count most recent)..."
    
    # Find all backup directories
    local backup_dirs=()
    while IFS= read -r -d '' dir; do
        backup_dirs+=("$dir")
    done < <(find "$(dirname "$BACKUP_BASE_DIR")" -maxdepth 1 -name "$(basename "$BACKUP_BASE_DIR").*" -type d -print0 2>/dev/null | sort -z)
    
    # Remove old backups if we have more than keep_count
    if [[ ${#backup_dirs[@]} -gt $keep_count ]]; then
        local to_remove=$((${#backup_dirs[@]} - keep_count))
        
        for ((i=0; i<to_remove; i++)); do
            local old_backup="${backup_dirs[i]}"
            log_message "INFO" "Removing old backup: $(basename "$old_backup")"
            rm -rf "$old_backup"
        done
        
        log_message "SUCCESS" "Cleaned up $to_remove old backup(s)"
    else
        log_message "INFO" "No old backups to clean up"
    fi
}

# Show usage information
show_usage() {
    cat << EOF
VaultMesh Dotfiles Backup Utility

Usage: $(basename "$0") [OPTIONS]

Options:
    -h, --help         Show this help message
    -v, --verbose      Enable verbose output
    -q, --quiet        Suppress non-error output
    -k, --keep COUNT   Number of backups to keep (default: 5)
    --no-cleanup       Skip cleanup of old backups
    --no-packages      Skip package manager configurations
    --no-history       Skip shell history files
    --list             List existing backups

Examples:
    $(basename "$0")                    # Create full backup
    $(basename "$0") --keep 10          # Keep 10 most recent backups
    $(basename "$0") --no-packages      # Skip package lists
    $(basename "$0") --list             # Show existing backups
EOF
}

# List existing backups
list_backups() {
    echo "📦 Existing Dotfiles Backups:"
    echo "============================"
    
    local backup_dirs=()
    while IFS= read -r -d '' dir; do
        backup_dirs+=("$dir")
    done < <(find "$(dirname "$BACKUP_BASE_DIR")" -maxdepth 1 -name "$(basename "$BACKUP_BASE_DIR").*" -type d -print0 2>/dev/null | sort -rz)
    
    if [[ ${#backup_dirs[@]} -eq 0 ]]; then
        echo "No backups found."
        return 0
    fi
    
    for backup_dir in "${backup_dirs[@]}"; do
        local backup_name=$(basename "$backup_dir")
        local backup_date="${backup_name##*.}"
        local formatted_date=""
        
        # Try to format the date
        if [[ $backup_date =~ ^[0-9]{8}_[0-9]{6}$ ]]; then
            formatted_date=$(date -j -f "%Y%m%d_%H%M%S" "$backup_date" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || echo "$backup_date")
        else
            formatted_date="$backup_date"
        fi
        
        local size=""
        if command -v du &> /dev/null; then
            size=$(du -sh "$backup_dir" 2>/dev/null | cut -f1 || echo "unknown")
        fi
        
        local file_count=""
        if [[ -f "$backup_dir/backup_info.txt" ]]; then
            file_count=$(grep -c "^FILE:\|^DIRECTORY:" "$backup_dir/backup_info.txt" 2>/dev/null || echo "unknown")
        fi
        
        echo "  📁 $backup_name"
        echo "     Date: $formatted_date"
        echo "     Size: ${size:-unknown}"
        echo "     Items: ${file_count:-unknown}"
        echo ""
    done
}

# Main execution
main() {
    local verbose=false
    local quiet=false
    local keep_count=5
    local skip_cleanup=false
    local skip_packages=false
    local skip_history=false
    local list_only=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_usage
                exit 0
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -q|--quiet)
                quiet=true
                shift
                ;;
            -k|--keep)
                keep_count="$2"
                shift 2
                ;;
            --no-cleanup)
                skip_cleanup=true
                shift
                ;;
            --no-packages)
                skip_packages=true
                shift
                ;;
            --no-history)
                skip_history=true
                shift
                ;;
            --list)
                list_only=true
                shift
                ;;
            *)
                error_exit "Unknown option: $1. Use --help for usage information."
                ;;
        esac
    done
    
    # Handle list option
    if [[ "$list_only" == true ]]; then
        list_backups
        exit 0
    fi
    
    # Redirect output if quiet mode
    if [[ "$quiet" == true ]]; then
        exec > /dev/null
    fi
    
    # Set verbose mode
    if [[ "$verbose" == true ]]; then
        set -x
    fi
    
    log_message "INFO" "Starting VaultMesh dotfiles backup..."
    
    # Create backup structure
    create_backup_structure
    
    # Backup files
    log_message "INFO" "Backing up configuration files..."
    local success_count=0
    local total_count=0
    
    for file in "${BACKUP_FILES[@]}"; do
        ((total_count++))
        if backup_file "$file"; then
            ((success_count++))
        fi
    done
    
    # Backup directories
    log_message "INFO" "Backing up configuration directories..."
    for dir in "${BACKUP_DIRS[@]}"; do
        ((total_count++))
        if backup_directory "$dir"; then
            ((success_count++))
        fi
    done
    
    # Backup shell history if not skipped
    if [[ "$skip_history" != true ]]; then
        backup_shell_history
    fi
    
    # Backup package configurations if not skipped
    if [[ "$skip_packages" != true ]]; then
        backup_package_configs
    fi
    
    # Create system snapshot
    create_system_snapshot
    
    # Verify backup
    verify_backup
    
    # Clean up old backups if not skipped
    if [[ "$skip_cleanup" != true ]]; then
        cleanup_old_backups "$keep_count"
    fi
    
    log_message "SUCCESS" "Backup completed successfully!"
    log_message "INFO" "Backup location: $BACKUP_DIR"
    log_message "INFO" "Files processed: $success_count/$total_count successful"
    
    echo ""
    echo "✅ Backup Summary:"
    echo "   Location: $BACKUP_DIR"
    echo "   Files: $success_count/$total_count"
    echo "   To restore: restore-dotfiles --from '$BACKUP_DIR'"
}

# Run main function with all arguments
main "$@"
